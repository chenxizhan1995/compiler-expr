目的：    编译原理，文法翻译示例--预测递归下降子程序分析法。

题目：   将简单的中缀表达式翻译为后缀表达式并输出。

        为简单起见，该中缀表达式是“由+、-号分隔的数位列表”，如 4+2-3

        文法的形式化描述：
            <list> -->  <list> + <digit>
                    |   <list> - <digit>
                    |   <digit>
            <digig> --> 1
                    |   2
                    |   3
                    |   4
                    |   5
                    |   6
                    |   7
                    |   8
                    |   9
设计：

    概述
        1.翻译要面向文法，
        2.此处词法分析可省略，
        3.语法分析的输出是语法分析树，
        4.语义分析，将文法扩展为语法制导定义，
        5.翻译，翻译为后缀形式,借助抽象语法树分析之，将语法制导定义转换为翻译方案，
        6.伪代码实现
        7.代码的简单优化

    语法分析
        语法分析的目的是：根据给定文法构建出给定输入串的语法分析树。
        分析时，需要扫描输入串，而当前正在扫描的那个符号，就是”向前看符号“。
        这里，采用递归下降子程序法分析。递归下降子程序法可用于语法分析和语法制导翻译。
        “递归下降子程序法”这个名字中，递归的意思是，每个非终结符号都有一个相关联的过程，对非终结符号的处理转换为该过程对其产生式体的模拟执行。语法分析过程就变成一堆函数之间的递归调用，而构建出的语法分析树就隐含在函数调用关系中。
        “下降”表明此法属于自顶向下分析法，自定向下分析法构造语法分析树的过程是这样的
            从标号为开始符号的非终结符号开始，反复执行下两个步骤
                1） 在标号为非终结符号A的节点N上，选择A的一个产生式，并为该产生式体的各个符号构造N的子节点，
                2） 寻找下一个节点来构造子树，通常，选择分析树中最左边的尚未扩展的非终结符。
            注：这里，如果A有多个产生式体，则需要使用某种方法从中选出一个，但这是更细节的问题了。

        这样，将递归子程序法引用到自顶向下分析法中，只要做如下对应：
            所有的节点要么是非终结符号节点，要么是终结符号节点。
            构建非终结符号节点，映射为对该非终结符号所关联的过程的调用；如果过程成功结束，则说明节点构建成功；
            构建终结符号节点，映射为向前看符号和该终结符号的匹配；如果匹配成功，则说明节点构建成功；
        为了使代码清晰，使用一个额外过程 match(t) 完成向前看符号和终结符号的匹配,其中，参数 t 是当前节点的终结符标号，match尝试把向前看符号 与 t 匹配，如果成功，则将向前看符号向前移动一个位置，并成功返回，如果失败，则启用错误处理程序，错误处理程序要么努力“修复”错误后成功返回（从而本次 match 调用成功返回），要么输出错误信息并终止分析过程。

        这里，指出，语法分析树是可以用数据结构表示的，所以它是实实在在的逻辑实体，故而可以这样说：“将语法分析树传递给语义分析器”。

    语义分析
        语义分析器假设已经得到一颗语法分析树，其任务是判定该分析树的语义是否合法。

        但现在还尚未定义何为语义。
        单纯对语义做形式化描述是很困难的，所以采用其它容易实现的方法，比如，我们可以这样做：
            我们可以为每个文法符号指定一个属性，并且，在得到语法分析树之后就有办法计算出所有节点的属性的具体值，而我们期望能够仅通过节点的属性的具体值便可轻易判断某处的节点是否符合语义，当所有节点都被判定为符合语义时，我们就说待分析的语法分析树是符合语义的。

            实践已经证明这个想法是切实可行的。比如，“语法制导定义”的概念。

        一个文法的语法制导定义指明的该文法的语义。
        我们通过做两件事得到一个文法的语法制导定义，第一件，为文法的每个文法符号附加一个属性集，第二，为每个产生式附加一个语义规则集。文法的语义就隐含在属性和规则集中。因为这种方式是依赖着文法，所以称为语法制导，而它在某种程度上给出了文法语义的“定义”，故合称语法制导定义。

        具体一点，属性可以是任何值，最开始的时候，对某些符合条件的节点的属性赋予一个初值，这些属性值作为求其他属性值的出发点。规则集就是对属性的一组操作，操作负责用其它已知属性值求其它位未知属性值，同时判断该以与该属性关联的节点为根的子树是否符合语义。对整棵分析树应用语义规则，便求出了所有节点的属性集。就是说，规则以属性值为依据判断当前节点是否符合语义。这论述解释了语义分析的实现机理。

        同时，在这里指出，我们采用的解决方案使得语义是隐含在计算属性值的过程中的，我们不曾得到任何表示语义的实体，也没有任何方法找出能够表示语义的逻辑实体（除非我们能够得到语义的形式化描述）。（这里的“逻辑实体”可以当作“数据结构”的同义词）
        更确切的说，仅当知道了相干属性的具体取值时，语义规则才能判定这些相干属性的取值对当前节点来说是否符合语义。

        再将目光转向语法分析树，如果将文法符号的属性在语法分析树中显示出来，无疑是利于问题的分析的，这样，修改过的分析树就叫它注释语法分析树。

    翻译
        翻译器假设已经得到一颗被判定为符合语义的语法分析树。其任务是对给定的语法分析树，根据其语义，将其转换为中间表示形式。
        但是，我们能够得到逻辑实体仅是分析树，并不能得到表示语义的逻辑实体，从而就无法从逻辑实体中直接取出“语义”。

        但这并不表示我们无法解决这个问题，我们重用语义分析中所采用的思想，为节点赋予属性，使得我们能仅根据属性值便可轻易地将当前节点翻译为想要的中间表示形式。但问题是某个节点的属性到底该取何值？我们说，至少得在得到语法分析树之后能够求出属性值才行。幸运的是。实践已经证明这种思路是切实可行的。而这思路分为三个部分：选取属性集、设计根据属性值得到翻译结果的算法、设计求属性值的算法，算法是什么？算法表现为一组操作，依前面的叫法，把这一组操作称为一个规则集，两个规则集加在一起是一个更大的规则集，于是，我们的解决方案可描述为：为文法中的每个文法符号附加一个属性集和一个规则集，然后将规则集中的规则应用到分析树的每个节点的属性上，求出所有节点的属性值并给出所有节点的翻译结果，所有节点的翻译结果则组成了整棵树的翻译结果。这样我们同样得到该文法的一套“语法制导定义”。还要指出，对同一个给定给定文法，这里为解决问题所选取的属性集与规则集是不同于语义分析中的属性集与规则集的。所以这两套语法制导定义是有区别的。

        接下来该考虑采用何种中间表示形式？抽象语法树和三地址代码是两个中间表示形式的例子。

    我们看到语义分析和翻译所采用的思想是一样的，既然如此，我们可以将两个步骤合并考虑，就是为每个文法符号附加一个大的属性集（这属性集是两个属性集的并集）和以个大的规则集（这规则集是两个规则集的并集），然后，在每个节点处，求属性集，判断语义是否正确，接着将节点翻译为中间表示形式，然后继续下一个节点。

    再指出，实践表明，语义制导定义便于分析，不便于实现，所以，我们在设计好语法制导定义后，常保留属性集不变，但把语义规则转变为等价的程序片段，为示区别，我们把转换后的东西称为“翻译方案”。同样将目光转向分析树，我们把代码片段当作节点，并用虚线将它们和父节点连接起来，得到增加了一些节点过的语法分析树。

    现在，我们依次得到了三棵树，分别是：语法分析树、语法制导制导定义的注释语法分析树、翻译方案的语法分析树。

    到这里，便可以将所有的分析转化为代码了，但在实现之前，再回顾一下整个过程，我们发现，语法分析、语义分析、翻译这三个过程都各自遍历一次整个语法分析树，这使我们自然地想到，是否可以将这三个过程合为一个过程，只遍历一次语法分析树便完成所有任务，而且，因为合并后，语法分析树不在外部使用，我们甚至可以不必显式给出语法分析树的表示。同样的理由，实践证明这种思路确实是可以的。

    根据设想，得到如下结果

    语法制导定义
                产生式                                  语义规则
        <list> -->  <list1> + <digit>   |       list.t = list1.t || digit.t || "+"
                |   <list1> - <digit>   |       list.t = list1.t || digit.t || "-"
                |   <digit>             |       list.t = digit.t
        <digig> --> 1                   |       digit.t = "1"
                |   2                   |       digit.t = "2"
                |   3                   |       digit.t = "3"
                |   4                   |       digit.t = "4"
                |   5                   |       digit.t = "5"
                |   6                   |       digit.t = "6"
                |   7                   |       digit.t = "7"
                |   8                   |       digit.t = "8"
                |   9                   |       digit.t = "9"

        其中，每个文法符号都附加一个名为t的属性，该属性的值是字符串类型。
        语义规则中，|| 表示字符串拼接，如“123”||“abc”的结果是字符串“123abc”。


    进一步转换为更利于实现的翻译方案
        <list> -->  <list> + <digit>    { print("+") }
                |   <list> - <digit>    { print("-") }
                |   <digit>
        <digig> --> 1           { print("1") }
                |   2           { print("2") }
                |   3           { print("3") }
                |   4           { print("4") }
                |   5           { print("5") }
                |   6           { print("6") }
                |   7           { print("7") }
                |   8           { print("8") }
                |   9           { print("9") }
        其中，花括号的作用是，表明其内部的语句是代码片段，产生式体中代码段和其他文法符号之间的相对位置代表了代码段执行的时机，这个代码段的位置，是假设采用深度优先、后续遍历语法分析树时所应有的位置。

    还剩下一个左递归问题，改写文法的范式：
        为消除产生式 A --> Aa | b 中的左递归，可将其改写为
            A --> bA'
            A' --> <空> | aA'
        显然，代价是引入了一个新的非终结符。

        改写文法时，代码段当作终结符号看待。
        <list> -->  <digit> <rest>
        <rest> -->  + <digit> { print("+") }  rest
                |   - <digit> { print("-") }  rest
                | <空>
        <digit> --> 1           { print("1") }
                |   2           { print("2") }
                |   3           { print("3") }
                |   4           { print("4") }
                |   5           { print("5") }
                |   6           { print("6") }
                |   7           { print("7") }
                |   8           { print("8") }
                |   9           { print("9") }

    接下来便是编程实现，在编写代码前先写出具体算法或伪代码是好的习惯。
    按照设想，每个非终结符关联一个过程,
    假设所有过程共享全局变量lookahead，lookahead是向前看符号。
    先是与开始符号关联的过程
    void list(){
        digit();
        rest();
    }
    然后是<rest>
    void rest(){
        if (lookahead == '+'){
                match('+'); /* 匹配字符+ */
                digit();
                print("+");
                rest();
        }else if (lookahead =='-'){
                match('-');
                digit();
                print("-");
                rest();
        }else {
            /* 对应于空产生式，不执行任何动作 */
        }

    }
    下面是digit
    void digit(){
        // 当然，可以用分支语句分别对应0--9，
        // 用下面的代码是等效的，而且更短
        if (lookahead 是数位){
            t = lookahead; // 保存当前数位，因为match会前移向前看符号。
            match(t);
            print(t);
        }else{
            report("语法错误");
        }
    }
    最后是额外的match
    void match(t){ // t - 待匹配的终结符号
        if (lookahead 和终结符号t相匹配){
            lookahead = nextTerminal;
        }else{
            report("语法错误");
        }
    }

    每个产生式对应一个分支，根据向前看符号选取分支，如果向前看符号不再任何分支内，则报告语法错误，除非有空产生式可用。
    产生式体中，按顺序处理，每个非终结符号转换为过程调用；每个非终结符号转换为match过程调用。match在匹配时前移向前看符号，在不匹配时报告语法错误。

    最后一步是代码优化，一般来说，代码优化工作应该交给更专业的编译器来做，但递归向下子程序法生成的程序常存在明显可优化的地方。
        尾递归消除
            如果过程的末尾是对过程自身的调用则过程就是尾递归的，形式参数为空的尾递归过程可以转换为跳转到过程开头的循环。rest过程就是尾递归的，它可以改写为
            void rest(){
                while(true){
                    if (lookahead == '+'){
                            match('+'); /* 匹配字符+ */
                            digit();
                            print("+");
                    }else if (lookahead =='-'){
                            match('-');
                            digit();
                            print("-");
                    }else {
                        /* 对应于空产生式，不执行任何动作 */
                    }
                    break;
                }
            }
        内联函数
            rest过程仅被过程list使用，而rest改写后不存在递归，所以可以将rest的实现代码整个移到list过程中，减少一次函数调用。
            void list(){
                digit();
                        while(true){
                            if (lookahead == '+'){
                                    match('+'); /* 匹配字符+ */
                                    digit();
                                    print("+");
                            }else if (lookahead =='-'){
                                    match('-');
                                    digit();
                                    print("-");
                            }else {
                                /* 对应于空产生式，不执行任何动作 */
                            }
                            break;
                        }
            }
        最终，伪代码是这样的

        ----------------------------------------
            void list(){
                digit();
                        while(true){
                            if (lookahead == '+'){
                                    match('+'); /* 匹配字符+ */
                                    digit();
                                    print("+");
                            }else if (lookahead =='-'){
                                    match('-');
                                    digit();
                                    print("-");
                            }else {
                                /* 对应于空产生式，不执行任何动作 */
                            }
                            break;
                        }
            }
            void digit(){
                // 当然，可以用分支语句分别对应0--9，
                // 用下面的代码是等效的，而且更短
                if (lookahead 是数位){
                    t = lookahead; // 保存当前数位，因为match会前移向前看符号。
                    match(t);
                    print(t);
                }else{
                    report("语法错误");
                }
            }
            void match(t){ // t - 待匹配的终结符号
                if (lookahead 和终结符号t相匹配){
                    lookahead = nextTerminal;
                }else{
                    report("语法错误");
                }
            }
        ----------------------------------------


    末了，还要指出，采用自定向下分析法，如果某个非终结符号有多个产生式体，那么在下一步推导中，选择哪个产生式上需要一个解决策略，我们可以选择逐个尝试每个产生式，但这将导致低效的回溯，我们也可以根据待分析串中下一个符号帮助我们确定该用哪个产生式，无疑第二种想法更高效，但第二种思路要求文法满足某些条件，幸运的是，对于目前的高级语言，几乎都有方法将它们的文法改写为等价的满足条件的文法。

